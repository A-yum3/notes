### Before

```javascript
organization = {name: "Acme Gooseberries", country: "GB"};
```

### After

```javascript
class Organization {
	constructor(data) {
		this._name = data.name;
		this._country = data.country;
	}
	get name() {return this._name;}
	set name(arg) {return this._name = arg;}
	get country() {return this._country;}
	set country() {return this._country = arg;}
}
```

### 動機

- 単純なレコード構造には欠点がある
	- レコードに格納されている値と計算した値の明確な区別を強要されること
	- 変更可能なデータについてはレコード化するよりもオブジェクト化したほうが良い
		- オブジェクトであれば、保持されているものを隠蔽できる
- 変更不可の値がある場合は、レコードをもたせ、必要に応じて値を付加するステップを施すこともできる。
- レコードは二種類ある
	- 正規にフィールド名を宣言したもの
	- 任意の名前を使えるもの
		- ハッシュ・マップ・ハッシュマップ・辞書・連想配列と呼ばれる

### 手順

- レコードを保持する変数に[[変数のカプセル化]]を施す
	- コード名をカプセル化するための関数には、検索しやすい名前をつける
- 変数の中身を、レコードをラップする簡単なクラスに置き換える。レコードをそのまま返すアクセサをそのクラスに定義する。変数をカプセル化する関数を変更して、アクセサを使うようにする。
- テストする
- レコードそのものではなくオブジェクトを返す関数を用意する
- レコードの使用箇所ごとに、レコードを返す関数の呼び出しを、オブジェクトを返す関数の呼び出しに置き換える。
	- フィールドデータの取得にはオブジェクトのアクセサを使うようにする。必要ならばそのためのアクセサを作る。変更のたびにテストする。
	- 入れ子構造を持つなど、レコードが複雑な場合は、まずデータを更新しているクライアントのコードに注目する。
- 生データへのアクセサと、検索しやすくしておいたレコードそのままを返す関数をクラスから取り除く
- テストする
- レコードのフィールド自体が構造体である場合、[[レコードのカプセル化]]と[[コレクションのカプセル化]]を再帰的に施すことを検討する

### 備考

- カプセル化したもののデータを直接変更することを禁じられない
	- ベースとなるデータのコピーを返すのがもっとも簡単
		- 大きなデータ構造をコピーするのにかかるコストがデメリット
- [[レコードのカプセル化]]を再帰的に施すのがもう一つの選択肢
	- 手間がかかるが、高度に制御できる
